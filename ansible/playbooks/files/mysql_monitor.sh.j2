#!/bin/bash

##############################################################################
# Script: mysql_monitoring.sh
# Description: Comprehensive MySQL database monitoring with InfluxDB integration
# Usage: ./mysql_monitoring.sh
# Generated by Ansible for {{ inventory_hostname }}
##############################################################################

# InfluxDB Primary Configuration
INFLUXDB_PRI_HOST="{{ influx_Pri_IP }}"
INFLUXDB_PRI_PORT="{{ influx_Pri_Port }}"
INFLUXDB_PRI_DATABASE="{{ influx_priDB_name }}"

# InfluxDB Secondary Configuration
{% if influx_Sec_IP is defined and influx_Sec_IP|length > 0 %}
INFLUXDB_SEC_ENABLED=1
INFLUXDB_SEC_HOST="{{ influx_Sec_IP }}"
INFLUXDB_SEC_PORT="{{ influx_Sec_Port }}"
INFLUXDB_SEC_DATABASE="{{ influx_secDB_name }}"
{% else %}
INFLUXDB_SEC_ENABLED=0
{% endif %}

# MySQL Configuration
{ % if mysql_servers is defined and mysql_servers|length > 0 % }
{ % if mysql_servers[0].host is defined % }
MYSQL_USER="{{ mysql_servers[0].user | default('root') }}"
MYSQL_PASSWORD="{{ mysql_servers[0].password | default('Root@123') }}"
MYSQL_HOST="{{ mysql_servers[0].host | default('localhost') }}"
MYSQL_PORT="{{ mysql_servers[0].port | default('3306') }}"
{ % elif mysql_servers.host is defined % }
MYSQL_USER="{{ mysql_servers.user | default('root') }}"
MYSQL_PASSWORD="{{ mysql_servers.password | default('Root@123') }}"
MYSQL_HOST="{{ mysql_servers.host | default('localhost') }}"
MYSQL_PORT="{{ mysql_servers.port | default('3306') }}"
{% else %}
MYSQL_USER="root"
MYSQL_PASSWORD="Root@123"
MYSQL_HOST="localhost"
MYSQL_PORT="3306"
{% endif %}
{% else %}
MYSQL_USER="root"
MYSQL_PASSWORD="Root@123"
MYSQL_HOST="localhost"
MYSQL_PORT="3306"
{ % endif % }

# Hostname for tagging (uppercase)
HOSTNAME="{{ inventory_hostname | upper }}"

# Get server internal IP (first non-localhost IP)
NODE_IP=$(hostname -I | awk '{print $1}')

# Additional tags
PROJECT="{{ project | default('AMX') }}"
ZONE="{{ zone | default('Unknown') }}"

# Custom temporary directory
TMP_DIR="/opt/airlinq/grafana"

echo "Creating temporary directory at $TMP_DIR"
mkdir -p "$TMP_DIR"
chmod 755 "$TMP_DIR"

# Temporary files
TEMP_STATUS="${TMP_DIR}/mysql_status_$$.txt"
TEMP_VARIABLES="${TMP_DIR}/mysql_variables_$$.txt"

# Get current timestamp in nanoseconds
TIMESTAMP=$(date +%s%N)

# Function to push data to InfluxDB (supports both primary and secondary)
push_to_influxdb() {
    local measurement=$1
    local tags=$2
    local fields=$3
    local timestamp=$4

    # Build InfluxDB line protocol
    local line_protocol="${measurement},${tags} ${fields} ${timestamp}"

    # Push to Primary InfluxDB
    curl -s -XPOST "http://${INFLUXDB_PRI_HOST}:${INFLUXDB_PRI_PORT}/write?db=${INFLUXDB_PRI_DATABASE}" \
        --data-binary "${line_protocol}" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "INFO: Data pushed to primary InfluxDB for measurement '${measurement}'"
    else
        echo "ERROR: Failed to push data to primary InfluxDB for measurement '${measurement}'"
    fi

# Push to Secondary InfluxDB only if enabled
if [ "$INFLUXDB_SEC_ENABLED" = "1" ]; then
    curl -s -XPOST "http://${INFLUXDB_SEC_HOST}:${INFLUXDB_SEC_PORT}/write?db=${INFLUXDB_SEC_DATABASE}" \
        --data-binary "${line_protocol}" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "INFO: Data pushed to secondary InfluxDB for measurement '${measurement}'"
    else
        echo "ERROR: Failed to push data to secondary InfluxDB for measurement '${measurement}'"
    fi
fi
}

# Function to get MySQL status variables
get_mysql_status() {
    mysql -u"${MYSQL_USER}" -p"${MYSQL_PASSWORD}" -h"${MYSQL_HOST}" -P"${MYSQL_PORT}" \
        -e "SHOW GLOBAL STATUS;" 2>/dev/null | grep -v "Variable_name" > "$TEMP_STATUS"

    if [ $? -ne 0 ]; then
        echo "ERROR: Failed to get MySQL status"
        return 1
    else
        echo "INFO: Successfully retrieved MySQL status"
    fi
}

# Function to get MySQL variables
get_mysql_variables() {
    mysql -u"${MYSQL_USER}" -p"${MYSQL_PASSWORD}" -h"${MYSQL_HOST}" -P"${MYSQL_PORT}" \
        -e "SHOW GLOBAL VARIABLES;" 2>/dev/null | grep -v "Variable_name" > "$TEMP_VARIABLES"

    if [ $? -ne 0 ]; then
        echo "ERROR: Failed to get MySQL variables"
        return 1
    else
        echo "INFO: Successfully retrieved MySQL variables"
    fi
}

# Function to get value from status file
get_status_value() {
    local var_name=$1
    grep "^${var_name}" "$TEMP_STATUS" | awk '{print $2}' | head -1
}

# Function to get value from variables file
get_variable_value() {
    local var_name=$1
    grep "^${var_name}" "$TEMP_VARIABLES" | awk '{print $2}' | head -1
}

# Function to safely get numeric value (returns 0 if empty)
safe_value() {
    local val=$1
    if [ -z "$val" ] || [ "$val" = "NULL" ]; then
        echo "0"
    else
        echo "$val"
    fi
}

# Function to collect and push metrics
collect_metrics() {
    # Build common tags (with uppercase hostname and nodeIP)
    local tags="host=${HOSTNAME},nodeIP=${NODE_IP},project=${PROJECT},zone=${ZONE}"

    # ========== 1. CONNECTION METRICS ==========
    local threads_connected=$(safe_value $(get_status_value "Threads_connected"))
    local threads_running=$(safe_value $(get_status_value "Threads_running"))
    local threads_cached=$(safe_value $(get_status_value "Threads_cached"))
    local threads_created=$(safe_value $(get_status_value "Threads_created"))
    local max_used_connections=$(safe_value $(get_status_value "Max_used_connections"))
    local aborted_connects=$(safe_value $(get_status_value "Aborted_connects"))
    local aborted_clients=$(safe_value $(get_status_value "Aborted_clients"))
    local connections=$(safe_value $(get_status_value "Connections"))
    local max_connections=$(safe_value $(get_variable_value "max_connections"))

    local connection_usage_pct=0
    if [ "$max_connections" -gt 0 ]; then
        connection_usage_pct=$(awk "BEGIN {printf \"%.2f\", ($threads_connected / $max_connections) * 100}")
    fi

    local conn_fields="threads_connected=${threads_connected}i,threads_running=${threads_running}i,threads_cached=${threads_cached}i,threads_created=${threads_created}i,max_used_connections=${max_used_connections}i,aborted_connects=${aborted_connects}i,aborted_clients=${aborted_clients}i,connections=${connections}i,max_connections=${max_connections}i,connection_usage_pct=${connection_usage_pct}"

    push_to_influxdb "mysql_connections" "$tags" "$conn_fields" "$TIMESTAMP"

    # ========== 2. QUERY PERFORMANCE METRICS ==========
    local queries=$(safe_value $(get_status_value "Queries"))
    local questions=$(safe_value $(get_status_value "Questions"))
    local slow_queries=$(safe_value $(get_status_value "Slow_queries"))
    local select_scan=$(safe_value $(get_status_value "Select_scan"))
    local select_full_join=$(safe_value $(get_status_value "Select_full_join"))
    local select_range=$(safe_value $(get_status_value "Select_range"))
    local select_range_check=$(safe_value $(get_status_value "Select_range_check"))

    local slow_query_pct=0
    if [ "$questions" -gt 0 ]; then
        slow_query_pct=$(awk "BEGIN {printf \"%.4f\", ($slow_queries / $questions) * 100}")
    fi

    local query_fields="queries=${queries}i,questions=${questions}i,slow_queries=${slow_queries}i,select_scan=${select_scan}i,select_full_join=${select_full_join}i,select_range=${select_range}i,select_range_check=${select_range_check}i,slow_query_pct=${slow_query_pct}"

    push_to_influxdb "mysql_queries" "$tags" "$query_fields" "$TIMESTAMP"

    # ========== 3. THROUGHPUT METRICS ==========
    local com_select=$(safe_value $(get_status_value "Com_select"))
    local com_insert=$(safe_value $(get_status_value "Com_insert"))
    local com_update=$(safe_value $(get_status_value "Com_update"))
    local com_delete=$(safe_value $(get_status_value "Com_delete"))
    local com_commit=$(safe_value $(get_status_value "Com_commit"))
    local com_rollback=$(safe_value $(get_status_value "Com_rollback"))
    local bytes_received=$(safe_value $(get_status_value "Bytes_received"))
    local bytes_sent=$(safe_value $(get_status_value "Bytes_sent"))

    local throughput_fields="com_select=${com_select}i,com_insert=${com_insert}i,com_update=${com_update}i,com_delete=${com_delete}i,com_commit=${com_commit}i,com_rollback=${com_rollback}i,bytes_received=${bytes_received}i,bytes_sent=${bytes_sent}i"

    push_to_influxdb "mysql_throughput" "$tags" "$throughput_fields" "$TIMESTAMP"

    # ========== 4. INNODB BUFFER POOL METRICS ==========
    local buffer_pool_size=$(safe_value $(get_variable_value "innodb_buffer_pool_size"))
    local buffer_pool_pages_total=$(safe_value $(get_status_value "Innodb_buffer_pool_pages_total"))
    local buffer_pool_pages_data=$(safe_value $(get_status_value "Innodb_buffer_pool_pages_data"))
    local buffer_pool_pages_dirty=$(safe_value $(get_status_value "Innodb_buffer_pool_pages_dirty"))
    local buffer_pool_pages_free=$(safe_value $(get_status_value "Innodb_buffer_pool_pages_free"))
    local buffer_pool_read_requests=$(safe_value $(get_status_value "Innodb_buffer_pool_read_requests"))
    local buffer_pool_reads=$(safe_value $(get_status_value "Innodb_buffer_pool_reads"))
    local buffer_pool_wait_free=$(safe_value $(get_status_value "Innodb_buffer_pool_wait_free"))
    local buffer_pool_write_requests=$(safe_value $(get_status_value "Innodb_buffer_pool_write_requests"))

    local buffer_pool_hit_ratio=0
    if [ "$buffer_pool_read_requests" -gt 0 ]; then
        buffer_pool_hit_ratio=$(awk "BEGIN {printf \"%.4f\", (($buffer_pool_read_requests - $buffer_pool_reads) / $buffer_pool_read_requests) * 100}")
    fi

    local buffer_fields="buffer_pool_size=${buffer_pool_size}i,buffer_pool_pages_total=${buffer_pool_pages_total}i,buffer_pool_pages_data=${buffer_pool_pages_data}i,buffer_pool_pages_dirty=${buffer_pool_pages_dirty}i,buffer_pool_pages_free=${buffer_pool_pages_free}i,buffer_pool_read_requests=${buffer_pool_read_requests}i,buffer_pool_reads=${buffer_pool_reads}i,buffer_pool_wait_free=${buffer_pool_wait_free}i,buffer_pool_write_requests=${buffer_pool_write_requests}i,buffer_pool_hit_ratio=${buffer_pool_hit_ratio}"

    push_to_influxdb "mysql_innodb_buffer_pool" "$tags" "$buffer_fields" "$TIMESTAMP"

    # ========== 5. INNODB I/O METRICS ==========
    local innodb_data_reads=$(safe_value $(get_status_value "Innodb_data_reads"))
    local innodb_data_writes=$(safe_value $(get_status_value "Innodb_data_writes"))
    local innodb_data_read=$(safe_value $(get_status_value "Innodb_data_read"))
    local innodb_data_written=$(safe_value $(get_status_value "Innodb_data_written"))
    local innodb_os_log_written=$(safe_value $(get_status_value "Innodb_os_log_written"))
    local innodb_data_fsyncs=$(safe_value $(get_status_value "Innodb_data_fsyncs"))

    local io_fields="innodb_data_reads=${innodb_data_reads}i,innodb_data_writes=${innodb_data_writes}i,innodb_data_read=${innodb_data_read}i,innodb_data_written=${innodb_data_written}i,innodb_os_log_written=${innodb_os_log_written}i,innodb_data_fsyncs=${innodb_data_fsyncs}i"

    push_to_influxdb "mysql_innodb_io" "$tags" "$io_fields" "$TIMESTAMP"

    # ========== 6. TABLE CACHE METRICS ==========
    local open_tables=$(safe_value $(get_status_value "Open_tables"))
    local opened_tables=$(safe_value $(get_status_value "Opened_tables"))
    local table_open_cache=$(safe_value $(get_variable_value "table_open_cache"))
    local table_locks_immediate=$(safe_value $(get_status_value "Table_locks_immediate"))
    local table_locks_waited=$(safe_value $(get_status_value "Table_locks_waited"))

    local table_cache_hit_ratio=0
    if [ "$opened_tables" -gt 0 ]; then
        table_cache_hit_ratio=$(awk "BEGIN {printf \"%.2f\", ($open_tables / $opened_tables) * 100}")
    fi

    local table_fields="open_tables=${open_tables}i,opened_tables=${opened_tables}i,table_open_cache=${table_open_cache}i,table_locks_immediate=${table_locks_immediate}i,table_locks_waited=${table_locks_waited}i,table_cache_hit_ratio=${table_cache_hit_ratio}"

    push_to_influxdb "mysql_table_cache" "$tags" "$table_fields" "$TIMESTAMP"

    # ========== 7. TEMPORARY TABLE METRICS ==========
    local created_tmp_tables=$(safe_value $(get_status_value "Created_tmp_tables"))
    local created_tmp_disk_tables=$(safe_value $(get_status_value "Created_tmp_disk_tables"))
    local created_tmp_files=$(safe_value $(get_status_value "Created_tmp_files"))

    local tmp_disk_pct=0
    if [ "$created_tmp_tables" -gt 0 ]; then
        tmp_disk_pct=$(awk "BEGIN {printf \"%.2f\", ($created_tmp_disk_tables / $created_tmp_tables) * 100}")
    fi

    local tmp_fields="created_tmp_tables=${created_tmp_tables}i,created_tmp_disk_tables=${created_tmp_disk_tables}i,created_tmp_files=${created_tmp_files}i,tmp_disk_pct=${tmp_disk_pct}"

    push_to_influxdb "mysql_temp_tables" "$tags" "$tmp_fields" "$TIMESTAMP"

    # ========== 8. SORT AND JOIN METRICS ==========
    local sort_range=$(safe_value $(get_status_value "Sort_range"))
    local sort_scan=$(safe_value $(get_status_value "Sort_scan"))
    local sort_merge_passes=$(safe_value $(get_status_value "Sort_merge_passes"))
    local sort_rows=$(safe_value $(get_status_value "Sort_rows"))

    local sort_fields="sort_range=${sort_range}i,sort_scan=${sort_scan}i,sort_merge_passes=${sort_merge_passes}i,sort_rows=${sort_rows}i"

    push_to_influxdb "mysql_sorts" "$tags" "$sort_fields" "$TIMESTAMP"

    # ========== 9. HANDLER METRICS ==========
    local handler_read_first=$(safe_value $(get_status_value "Handler_read_first"))
    local handler_read_key=$(safe_value $(get_status_value "Handler_read_key"))
    local handler_read_next=$(safe_value $(get_status_value "Handler_read_next"))
    local handler_read_rnd=$(safe_value $(get_status_value "Handler_read_rnd"))
    local handler_read_rnd_next=$(safe_value $(get_status_value "Handler_read_rnd_next"))

    local handler_fields="handler_read_first=${handler_read_first}i,handler_read_key=${handler_read_key}i,handler_read_next=${handler_read_next}i,handler_read_rnd=${handler_read_rnd}i,handler_read_rnd_next=${handler_read_rnd_next}i"

    push_to_influxdb "mysql_handlers" "$tags" "$handler_fields" "$TIMESTAMP"

    # ========== 10. INNODB ROW OPERATIONS ==========
    local innodb_rows_read=$(safe_value $(get_status_value "Innodb_rows_read"))
    local innodb_rows_inserted=$(safe_value $(get_status_value "Innodb_rows_inserted"))
    local innodb_rows_updated=$(safe_value $(get_status_value "Innodb_rows_updated"))
    local innodb_rows_deleted=$(safe_value $(get_status_value "Innodb_rows_deleted"))

    local row_fields="innodb_rows_read=${innodb_rows_read}i,innodb_rows_inserted=${innodb_rows_inserted}i,innodb_rows_updated=${innodb_rows_updated}i,innodb_rows_deleted=${innodb_rows_deleted}i"

    push_to_influxdb "mysql_innodb_rows" "$tags" "$row_fields" "$TIMESTAMP"

    # ========== 11. LOCK METRICS ==========
    local innodb_row_lock_waits=$(safe_value $(get_status_value "Innodb_row_lock_waits"))
    local innodb_row_lock_time=$(safe_value $(get_status_value "Innodb_row_lock_time"))
    local innodb_row_lock_time_avg=$(safe_value $(get_status_value "Innodb_row_lock_time_avg"))
    local innodb_row_lock_current_waits=$(safe_value $(get_status_value "Innodb_row_lock_current_waits"))
    local innodb_deadlocks=$(safe_value $(get_status_value "Innodb_deadlocks"))

    local lock_fields="innodb_row_lock_waits=${innodb_row_lock_waits}i,innodb_row_lock_time=${innodb_row_lock_time}i,innodb_row_lock_time_avg=${innodb_row_lock_time_avg}i,innodb_row_lock_current_waits=${innodb_row_lock_current_waits}i,innodb_deadlocks=${innodb_deadlocks}i"

    push_to_influxdb "mysql_locks" "$tags" "$lock_fields" "$TIMESTAMP"

    # ========== 12. UPTIME ==========
    local uptime=$(safe_value $(get_status_value "Uptime"))

    local uptime_fields="uptime=${uptime}i"

    push_to_influxdb "mysql_uptime" "$tags" "$uptime_fields" "$TIMESTAMP"

    # ========== 13. THREAD CACHE ==========
    local thread_cache_size=$(safe_value $(get_variable_value "thread_cache_size"))

    local thread_cache_hit_ratio=0
    if [ "$connections" -gt 0 ]; then
        thread_cache_hit_ratio=$(awk "BEGIN {printf \"%.2f\", (1 - ($threads_created / $connections)) * 100}")
    fi

    local thread_cache_fields="thread_cache_size=${thread_cache_size}i,thread_cache_hit_ratio=${thread_cache_hit_ratio}"

    push_to_influxdb "mysql_thread_cache" "$tags" "$thread_cache_fields" "$TIMESTAMP"

    # ========== 14. BINLOG METRICS ==========
    local binlog_cache_use=$(safe_value $(get_status_value "Binlog_cache_use"))
    local binlog_cache_disk_use=$(safe_value $(get_status_value "Binlog_cache_disk_use"))

    local binlog_fields="binlog_cache_use=${binlog_cache_use}i,binlog_cache_disk_use=${binlog_cache_disk_use}i"

    push_to_influxdb "mysql_binlog" "$tags" "$binlog_fields" "$TIMESTAMP"
}

# Main execution
get_mysql_status
if [ $? -ne 0 ]; then
    echo "ERROR: Unable to proceed due to failure in fetching MySQL status."
    exit 1
fi

get_mysql_variables
if [ $? -ne 0 ]; then
    echo "ERROR: Unable to proceed due to failure in fetching MySQL variables."
    exit 1
fi

collect_metrics

# Cleanup
rm -f "$TEMP_STATUS" "$TEMP_VARIABLES"
echo "INFO: Temporary files cleaned up."

exit 0
