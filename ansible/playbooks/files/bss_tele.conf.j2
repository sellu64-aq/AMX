##############################################################################
# Script: Telegraf bss Status
# Description: BSS monitoring with InfluxDB integration
# Usage: with Telegraf
# Generated by Ansible for {{ inventory_hostname }}
# Develop: K. Selvam Enoch (777)
##############################################################################

[global_tags]
  project = "{{ project }}"
  zone = "{{ zone }}"
  nodeIP = "{{ ansible_host }}"
  service = "bss"

[agent]
  debug = true
  quiet = false
  interval = "30s"
  flush_interval = "10s"
  logfile = "{{ telegraf_remote_path }}/telegraf/logs/{{ telegraf_name }}_telegraf.log"
  hostname = "{{ inventory_hostname }}"
  omit_hostname = false
  round_interval = true
  metric_batch_size = 5000
  metric_buffer_limit = 20000
  collection_jitter = "5s"
  flush_jitter = "5s"
  precision = "1ms"
  logfile_rotation_interval = "12h"
  logfile_rotation_max_size = "100MB"
  logfile_rotation_max_archives = 5

####### Port Status for {{ inventory_hostname }} #######
{% for item in ports %}
[[inputs.net_response]]
  protocol = "tcp"
  address = "{{ item.ip }}:{{ item.port }}"
  name_override = "portResponsetime"
  tags = { linkName="{{ item.name }}", ip="{{ item.ip }}", port="{{ item.port }}", host="{{ inventory_hostname }}" }
{% endfor %}

############## Ping Monitoring ################
[[inputs.ping]]
  {% set unique_ips = ports | map(attribute='ip') | unique %}
  urls = [{% for ip in unique_ips %}"{{ ip }}"{% if not loop.last %}, {% endif %}{% endfor %}]
  count = 2
  ping_interval = 3.0
  timeout = 2.0
  method = "exec"

##### App Metrics ###########
[[inputs.exec]]
  commands = ["{{ telegraf_remote_path }}/scripts/{{ telegraf_name }}_app_metrics.sh"]
  data_format = "influx"
  name_override = "app_metrics"
  interval = "1m"
  timeout = "50s"

############# Port Monitor #############
[[inputs.exec]]
  commands = ["{{ telegraf_remote_path }}/scripts/{{ telegraf_name }}_port_listen_monitor.sh"]
  timeout = "10s"
  data_format = "influx"
  name_override = "port_listen"

############# Port Monitor #############
[[inputs.exec]]
  commands = ["{{ telegraf_remote_path }}/scripts/{{ telegraf_name }}_port_conn_monitor.sh"]
  timeout = "10s"
  data_format = "influx"
  name_override = "link_count"

###### LOCALHOST ACCESS LOGS ########
################
[[inputs.tail]]
  files = ["/opt/webservers/bss_1/logs/localhost_access_log.*.txt"]
  name_override = "access_log"
  data_format = "grok"
  initial_read_offset = "end"
  tags = { app = "bss1" }
  grok_patterns = [
    '%{IP:client_ip} - - \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{DATA:full_path} HTTP/%{NUMBER:http_version}" %{INT:response_code} %{INT:response_size}(?:\s*\[%{INT:request_duration}\])?'
  ]
  grok_custom_patterns = '''
HTTPDATE %{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} %{ISO8601_TIMEZONE}
'''

#######################
# Processor: Extract API name from path (before the ?)
#######################
[[processors.regex]]
  namepass = ["access_log"]
  order = 1
  [[processors.regex.fields]]
    key = "full_path"
    # Extract everything before the query string
    pattern = '^([^\?]+)'
    replacement = '${1}'
    result_key = "path_only"

#######################
# Processor: Extract the last segment as API name
#######################
[[processors.regex]]
  namepass = ["access_log"]
  order = 2
  [[processors.regex.fields]]
    key = "path_only"
    # Extract last segment: /backend/st/json/UserRequest -> UserRequest
    pattern = '.*/([^/]+)$'
    replacement = '${1}'
    result_key = "api_name"

#######################
# Processor: Extract query string for additional parsing if needed
#######################
[[processors.regex]]
  namepass = ["access_log"]
  order = 3
  [[processors.regex.fields]]
    key = "full_path"
    # Extract query string
    pattern = '\?(.+)$'
    replacement = '${1}'
    result_key = "querystring"

#######################
# Processor: Tag static assets
#######################
[[processors.regex]]
  namepass = ["access_log"]
  [[processors.regex.fields]]
    key = "path_only"
    pattern = '.*\.(js|css|png|jpg|jpeg|ico|svg|woff2?|action|html|gif|map|ttf|otf)$'
    replacement = "static"
    result_key = "asset_type"

#######################
# Processor: Convert fields to tags and integers
#######################
[[processors.converter]]
  namepass = ["access_log"]
  [processors.converter.fields]
    tag = ["api_name", "method", "response_code", "asset_type"]
    integer = ["response_size", "request_duration"]

#######################
# Processor: Drop the temporary fields
#######################
[[processors.strings]]
  namepass = ["access_log"]
  [[processors.strings.trim]]
    field = "api_name"

################
[[inputs.tail]]
  files = ["/opt/webservers/bss_2/logs/localhost_access_log.*.txt"]
  name_override = "access_log"
  data_format = "grok"
  initial_read_offset = "end"
  tags = { app = "bss2" }
  grok_patterns = [
    '%{IP:client_ip} - - \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{DATA:full_path} HTTP/%{NUMBER:http_version}" %{INT:response_code} %{INT:response_size}(?:\s*\[%{INT:request_duration}\])?'
  ]
  grok_custom_patterns = '''
HTTPDATE %{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} %{ISO8601_TIMEZONE}
'''

#######################
# Processor: Extract API name from path (before the ?)
#######################
[[processors.regex]]
  namepass = ["access_log"]
  order = 1
  [[processors.regex.fields]]
    key = "full_path"
    # Extract everything before the query string
    pattern = '^([^\?]+)'
    replacement = '${1}'
    result_key = "path_only"

#######################
# Processor: Extract the last segment as API name
#######################
[[processors.regex]]
  namepass = ["access_log"]
  order = 2
  [[processors.regex.fields]]
    key = "path_only"
    # Extract last segment: /backend/st/json/UserRequest -> UserRequest
    pattern = '.*/([^/]+)$'
    replacement = '${1}'
    result_key = "api_name"

#######################
# Processor: Extract query string for additional parsing if needed
#######################
[[processors.regex]]
  namepass = ["access_log"]
  order = 3
  [[processors.regex.fields]]
    key = "full_path"
    # Extract query string
    pattern = '\?(.+)$'
    replacement = '${1}'
    result_key = "querystring"

#######################
# Processor: Tag static assets
#######################
[[processors.regex]]
  namepass = ["access_log"]
  [[processors.regex.fields]]
    key = "path_only"
    pattern = '.*\.(js|css|png|jpg|jpeg|ico|svg|woff2?|action|html|gif|map|ttf|otf)$'
    replacement = "static"
    result_key = "asset_type"

#######################
# Processor: Convert fields to tags and integers
#######################
[[processors.converter]]
  namepass = ["access_log"]
  [processors.converter.fields]
    tag = ["api_name", "method", "response_code", "asset_type"]
    integer = ["response_size", "request_duration"]

#######################
# Processor: Drop the temporary fields
#######################
[[processors.strings]]
  namepass = ["access_log"]
  [[processors.strings.trim]]
    field = "api_name"


### TAIL catalina.out logs
[[inputs.tail]]
  files = ["/opt/webservers/bss_1/logs/catalina.out"]
  from_beginning = false
  name_override = "Catalina_logs"
  data_format = "grok"
  tags = { app = "bss1" }
  grok_patterns = ['%{CATALINA_LOG_LINE}']

grok_custom_patterns = '''
CATALINA_LOG_LINE %{TIMESTAMP_ISO8601:timestamp} \[%{DATA:thread}\] %{LOGLEVEL:log_level} %{JAVACLASS:class}: %{GREEDYDATA:message}
JAVACLASS (?:[A-Za-z0-9_$\.]+)
'''

[[processors.converter]]
  namepass = ["Catalina_logs"]
  [processors.converter.fields]
    tag = ["class", "log_level"]

[[inputs.tail]]
  files = ["/opt/webservers/bss_2/logs/catalina.out"]
  from_beginning = false
  name_override = "Catalina_logs"
  data_format = "grok"
  tags = { app = "bss2" }
  grok_patterns = ['%{CATALINA_LOG_LINE}']

grok_custom_patterns = '''
CATALINA_LOG_LINE %{TIMESTAMP_ISO8601:timestamp} \[%{DATA:thread}\] %{LOGLEVEL:log_level} %{JAVACLASS:class}: %{GREEDYDATA:message}
JAVACLASS (?:[A-Za-z0-9_$\.]+)
'''

[[processors.converter]]
  namepass = ["Catalina_logs"]
  [processors.converter.fields]
    tag = ["class", "log_level"]

### OUTPUTS Pri #####
[[outputs.influxdb]]
  urls = ["http://{{ influx_Pri_IP }}:{{ influx_Pri_Port }}"]
  database = "{{ influx_priDB_name }}"
  retention_policy = "thirty_days"
  timeout = "5s"
  skip_database_creation = true
  namepass = ["port_listen","link_count","app_metrics","portResponsetime","ping"]

[[outputs.influxdb]]
  urls = ["http://{{ influx_Pri_IP }}:{{ influx_Pri_Port }}"]
  database = "{{ influx_priDB_name }}"
  retention_policy = "1hrRP"
  timeout = "5s"
  skip_database_creation = true
 # namepass = ["access_log", "Catalina_logs"]
  namepass = ["Catalina_logs"]

{% if influx_Sec_IP is defined and influx_Sec_IP|length > 0 %}
### OUTPUTS Sec #####
[[outputs.influxdb]]
  urls = ["http://{{ influx_Sec_IP }}:{{ influx_Sec_Port }}"]
  database = "{{ influx_secDB_name }}"
  retention_policy = "thirty_days"
  timeout = "5s"
  skip_database_creation = true
  namepass = ["port_listen","link_count","app_metrics","portResponsetime","ping"]

[[outputs.influxdb]]
  urls = ["http://{{ influx_Sec_IP }}:{{ influx_Sec_Port }}"]
  database = "{{ influx_secDB_name }}"
  retention_policy = "1hrRP"
  timeout = "5s"
  skip_database_creation = true
 # namepass = ["access_log", "Catalina_logs"]
  namepass = ["Catalina_logs"]
{% endif %}